import "./style.css"
import { WebSocketMessage } from "./types";

// Setup Web Socket
const webSocketProtocol = window.location.protocol === "https:" ? "wss" : "ws";

let webSocketHost = window.location.host; // No matter the public url generated by ngrok, client can still connect to the server.
if (import.meta.env.MODE === "development") {
    console.log("Development environment. Setting host to localhost:3000");
    webSocketHost = "localhost:3000"; // Vite dev server hosts on localhost:5173
}

const socketURL = `${webSocketProtocol}://${webSocketHost}/`;
console.log("Creating socket on url:", socketURL);

const socket = new WebSocket(`${webSocketProtocol}://${webSocketHost}/`);

function sendMessage(text: string) {
    console.log("sendMessage:", text);

    if (socket.readyState !== WebSocket.OPEN)
        return;

    const message: WebSocketMessage = { origin: "web-controller", message: text };
    socket.send(JSON.stringify(message));
}

socket.onopen = () => {
    sendMessage("connected");
};

socket.onmessage = (message) => {
    console.log("Received server message:", message.data);
};

// Setup buttons
const leftButton = document.getElementById("left-button");
const rightButton = document.getElementById("right-button");

const fireButton = document.getElementById("fire-button");
const dashButton = document.getElementById("dash-button");
const jumpButton = document.getElementById("jump-button");

if (!leftButton || !rightButton || !fireButton || !dashButton || !jumpButton) {
    throw new Error("Cannot find all buttons!");
}

addEventListeners("left", leftButton);
addEventListeners("right", rightButton);

addEventListeners("fire", fireButton);
addEventListeners("dash", dashButton);
addEventListeners("jump", jumpButton);

function addEventListeners(name: string, element: HTMLElement) {

    /* Note

    The experience is not that smooth on mobile. 
    Some "keyup" events are lost and not always registered.

    There is also no native "touchleave" event.

    "touchleave" would need to be manually implemented by checking coordinates.

    References
    - https://stackoverflow.com/questions/5748476/javascript-equivalent-of-mouseleave-for-touch-interactions
    - https://stackoverflow.com/questions/9266322/how-to-detect-touch-move-out-of-a-node-with-javascript

    */

    element.addEventListener("touchstart", () => {
        // console.log("touchstart")
        sendMessage(`keydown-${name}`);
    });

    element.addEventListener("touchend", () => {
        // console.log("touchend")
        sendMessage(`keyup-${name}`);
    });

    element.addEventListener("touchcancel", () => {
        // console.log("touchcancel")
        sendMessage(`keyup-${name}`);
    });

    element.addEventListener("mousedown", () => {
        // console.log("mousedown")
        sendMessage(`keydown-${name}`);
    });

    element.addEventListener("mouseup", () => {
        // console.log("mouseup")
        sendMessage(`keyup-${name}`);
    });

    element.addEventListener("mouseleave", () => {
        // console.log("mouseleave")
        sendMessage(`keyup-${name}`);
    });
}

